library(shiny)
library(dplyr)
library(ggplot2)
library(stats)
library(Hmisc)
library(snakecase)

source('./src/data_paths.R')

choro_inputs = read.csv(paste(new_data, 'choropleth_inputs.csv', sep = ''),
                        stringsAsFactors = FALSE)
choro_inputs$ZCTA = as.character(choro_inputs$ZCTA)
df = choro_inputs %>% 
  distinct(ZCTA, .keep_all = TRUE)

pretty_columns = read.csv(paste(new_data, 'pretty_column_names.csv', sep = ''),
                          stringsAsFactors = FALSE)
pretty_columns = pretty_columns %>% 
  filter(!is.na(split_word))
pretty_columns$l2[pretty_columns$l2 == ''] = ' '
pretty_columns = pretty_columns %>% 
  mutate(formatted_name = paste(l1, l2, sep = "\n"))

# Uses dataframe generated by generate_choro_df to plot desired outcomes
build_choropleth <- function(choro_df, var_label, pretty_label,
                             min_color = 'lightgrey', max_color = 'darkblue',
                             show_title = F){
  if(show_title){
    new_title = pretty_label
  }else{
    new_title = ''
  }
  
  p = ggplot() + 
    geom_polygon(data=choro_df %>% filter(!is.na(.data[[var_label]])), 
                 aes(x=long, y=lat, group=group, fill = .data[[var_label]]),
                 color = 'white', size = 0.2) +
    scale_fill_gradient(low = min_color, high = max_color, 
                        guide = 
                          guide_colorbar(
                            title = pretty_label,order = 1,reverse = F
                          )
    )+
    theme(panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank()) +
    labs(title=new_title,
         x ="", y = "")
  
  return(p)
}

get_correlations <- function(df){
  merged.rcorr = rcorr(as.matrix(df))
  merged.coeff = merged.rcorr$r
  merged.p = merged.rcorr$P
  if(merged.coeff[1,1]!=1.0){
    r_val = merged.coeff[1,1]
    p_val = merged.p[1,1]
  }else{
    r_val = merged.coeff[1,2]
    p_val = merged.p[1,2]
  }
  return(c(r_val, p_val))
}


# Define UI for app that draws a histogram ----
# Define UI for app that draws a histogram ----
ui <- fluidPage(
  
  # App title ----
  titlePanel("COVID-19 in NYC: Comparisons with Census Demographic Data"),
  br(),
  # Sidebar layout with input and output definitions ----
  sidebarLayout(
    # Sidebar panel for inputs ----
    sidebarPanel(
      h4(selectInput(inputId = "outcome_var",
                     label = "COVID-19 outcome:",
                     c('Percent Positive COVID Tests' = 'PERCENT_POSITIVE',
                       "Case rate per 100,000" = 'COVID_CASE_RATE',
                       'Death rate per 100,000' = 'COVID_DEATH_RATE'),
                     selected = 'Percent Positive COVID Tests')),
      h4(selectInput(inputId = 'demo_var',
                     label = "Census demographic variable:",
                     c("Median income" = 'median_income',
                       'Median rent' = 'median_rent',
                       'Percent with disability' = 'percent_with_disability',
                       'Percent White' = 'percent_white',
                       'Percent Black' = 'percent_black',
                       'Percent Asian' = 'percent_asian',
                       'Percent Hispanic/Latino' = 'percent_hispanic_latino',
                       'Percent uninsured' = 'percent_uninsured',
                       'Percent receiving public assistance' = 'percent_receiving_public_assistance',
                       'High school completion rate' = 'high_school_completion',
                       'College completion rate' = 'college_graduates',
                       'Percent working in managment, arts, sciences' = 'percent_in_mgmt_art_sci',
                       'Poverty rate' = 'poverty_rate',
                       'Percent spending >=35% of income on rent' = 'percent_spending_35_percent_rent'),
                     selected = 'Median income')),
      h4('Plot options: '),
      checkboxInput(inputId = 'show_by_borough',
                    label = h4('Show color coding for boroughs?'),
                    value = TRUE),
      checkboxInput(inputId = 'show_reg_line',
                    label = h4('Show linear relationship between variables?'),
                    value = TRUE),
      br(),
      h5(uiOutput("acs_ref"),
         align = 'center'),
      h5(uiOutput("covid_github_ref"),
         align = 'center')
      
    ),
    
    # Main panel for displaying outputs ----
    mainPanel(
      
      fluidRow(
        column(6,
               h4(textOutput(outputId = "cov_pretty")),
               plotOutput(outputId = "cov_plot")
        ),
        column(6,
               h4(textOutput(outputId = "demo_pretty")),
               plotOutput(outputId = "census_plot")
        )
      ),
      br(),
      hr(),
      h4(textOutput(outputId = 'correlation_plot_head')),
      h5(uiOutput("stats_ref")),
      plotOutput(outputId = "correlation_plot"),
      br(),
      h5('All data are represented at the ZIP code or modified ZIP code level', 
         align = 'center'),
      h5('Last updated: 22 May 2020', 
         align = 'center'),
      h5(uiOutput('app_github_ref'),
         align = 'center'),
      br(),
      br()
    )
  )
)

# Define server logic required to draw a histogram ----
server <- function(input, output) {
  get_corr_vars <- reactive({
    vars = df %>% 
      select(c(input$demo_var, input$outcome_var,
               Borough))
    colnames(vars) = c('x', 'y', 'Borough')
    vars
  })
  
  get_pretty_labels <- reactive({
    lab1 = pretty_columns %>% filter(original_name == input$demo_var)
    rownames(lab1) = c(1)
    lab1 = lab1$formatted_name[1]
    lab2 = pretty_columns %>% filter(original_name == input$outcome_var)
    rownames(lab2) = c(1)
    lab2 = lab2$formatted_name[1]
    labs = c(lab1, lab2)
    labs
  })
  
  get_choro_df <- reactive({
    temp = df %>% 
      select(c(input$demo_var, input$outcome_var,
               ZCTA)) 
    temp
  })
  
  output$demo_pretty <- renderText({
    pretty = get_pretty_labels()
    paste(pretty[1])
  })
  
  output$cov_pretty <- renderText({
    pretty = get_pretty_labels()
    paste(pretty[2])
  })
  
  output$correlation_plot_head <- renderText({
    labs = get_pretty_labels()
    paste(sprintf('Correlation Between %s and %s', 
                  labs[2], labs[1]))
  })
  
  stats_url = a("What does this mean?",
                href = "https://statistics.laerd.com/statistical-guides/pearson-correlation-coefficient-statistical-guide.php")
  output$stats_ref <- renderUI({
    temp = get_choro_df()
    temp = temp %>% select(-c(ZCTA))
    corr_vals = get_correlations(temp)
    if(corr_vals[2]<0.001){
      pval = '< 0.001'
    }else{
      pval = sprintf("= %s", round(corr_vals[2], 3))
    }
    new_str = sprintf("Pearson's r = %s, p-value %s. ",
                      as.character(round(corr_vals[1], 2)),
                      pval)
    tagList(new_str, stats_url)
  })
  
  github_url <- a("on Github", href="https://github.com/silverer/covid_nyc_map/")
  output$app_github_ref <- renderUI({
    tagList("The code for this app is available ", github_url)
  })
  
  acs_url <- a("American Community Survey 2014-2018",
               href="https://www.census.gov/programs-surveys/acs/")
  output$acs_ref <- renderUI({
    tagList("Demographic data are sourced from the US Census ", acs_url)
  })
  covid_url = a("NYC Health Dept",
                href = "https://www.github.com/nychealth/coronavirus-data")
  output$covid_github_ref <- renderUI({
    tagList("COVID-19 data are sourced from the ", covid_url, " and aggregated over all time")
  })
  
  
  
  output$correlation_plot <- renderPlot({
    temp = get_corr_vars()
    plot_labels = get_pretty_labels()
    temp = temp %>% 
      filter(!is.na(x) & !is.na(y))
    if(input$show_by_borough==TRUE){
      if(input$show_reg_line==TRUE){
        p = ggplot(temp, aes(x, y))+
          geom_point(aes(color=Borough)) +
          geom_smooth(method = 'lm', se = FALSE, formula = y ~ x) +
          labs(x = plot_labels[1], y = plot_labels[2])+
          theme(text = element_text(size = 20))
      }else{
        p = ggplot(temp, aes(x, y, color=Borough))+
          geom_point() +
          labs(x = plot_labels[1], y = plot_labels[2])+
          theme(text = element_text(size = 20))
      }
      
    }else{
      p = ggplot(temp, aes(x, y))+
        geom_point() +
        labs(x = plot_labels[1], y = plot_labels[2]) +
        theme(text = element_text(size = 20))
      if(input$show_reg_line){
        p = p + geom_smooth(method="lm", se=FALSE, formula = y ~ x)
      }
    }
    
    p
  })
  
  output$census_plot <- renderPlot({
    choro_inputs
    temp = get_choro_df()
    labs = get_pretty_labels()
    p = build_choropleth(choro_inputs, input$demo_var,
                         labs[1])
    p
  })
  
  output$cov_plot <- renderPlot({
    choro_inputs
    temp = get_choro_df()
    labs = get_pretty_labels()
    p = build_choropleth(choro_inputs, input$outcome_var,
                         labs[2])
    p
  })
  
}

shinyApp(ui, server)