library(dplyr)
library(ggplot2)
library(stats)
library(Hmisc)
library(ggcorrplot)

## Test suite for plotting geospatial data

#######################################
# Set path and global variables
#######################################

setwd("~/Documents/covid_nyc_map/")
source('./data_paths.R')

SAVE_FIGS = FALSE
vars = read.csv(paste(new_data, 'census_variables.csv', sep = ''),
                    stringsAsFactors = F)
merged = read.csv(paste(new_data, merged_fname, sep= ''),
                  stringsAsFactors = F)
merged = merged %>% 
  select(-c(X))
  
merged$ZCTA = as.character(merged$ZCTA)

nyc_fips = c('36005', '36047', '36061', '36081', '36085')

plot_cols = vars %>% 
  filter(is.na(pretty_label)==FALSE & pretty_label != '')

new_vars = vars %>% 
  filter(variable_label %in% plot_cols)
pretty_cols = as.vector(new_vars$pretty_label)
plot_cols = as.vector(new_vars$variable_label)


# Uses dataframe generated by generate_choro_df to plot desired outcomes
build_choropleth <- function(choro_df, var_label, 
                             min_color = 'lightgrey', max_color = 'darkblue'){
  p = ggplot() + 
    geom_polygon(data=choro_df %>% filter(!is.na(.data[[var_label]])), 
                 aes(x=long, y=lat, group=group, fill = .data[[var_label]]),
                 color = 'white', size = 0.2) +
    scale_fill_gradient(low = min_color, high = max_color, 
                        guide = 
                          guide_colorbar(
                            title = var_label,order = 1,reverse = F
                          )
    )+
    theme(panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          axis.text.x = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank()) +
    labs(title=sprintf('%s', var_label),
         x ="", y = "")+
    theme(plot.title = element_text(size = 20, hjust = 0.5,
                                    vjust = -2),
          legend.title = element_text(size = 16))
  
  return(p)
}


choro_inputs = read.csv(paste(new_data, 'choropleth_inputs.csv', sep = ''),
                        stringsAsFactors = FALSE)
choro_inputs = choro_inputs %>% 
  rename(`Median income` = median_income)
test_plot = build_choropleth(choro_inputs, 'Median income')
print(test_plot)

# figname = sprintf("%s_choropleth.png", plot_cols[2])
# png(paste(figs, figname, sep = ''), width = 13, 
#     height = 13, units = "in", res = 250)

# Uses dataframe generated by generate_choro_df to plot desired outcomes
build_corr_plot <- function(df, xvar, yvar,
                            show_reg, show_boro){
  
  plot_df = df %>% 
    dplyr::filter(!is.na(.data[[xvar]]) & !is.na(.data[[yvar]])) %>% 
    dplyr::distinct(ZCTA, .keep_all = TRUE)
  
  if(show_boro==TRUE){
    p = ggplot(plot_df, aes(.data[[xvar]], .data[[yvar]], label = ZCTA))+
      geom_point(aes(color=Borough)) +
      labs(x = xvar, y = yvar)
  }else{
    p = ggplot(plot_df, aes(.data[[xvar]], .data[[yvar]], label = ZCTA))+
      geom_point()
  }
  if(show_reg==TRUE){
    p = p +  geom_smooth(method = 'lm', se = FALSE, formula = y ~ x)
  }
  p = p + theme(panel.background = element_blank(),
                axis.line = element_line(colour = "black"),
                text = element_text(size = 16),
                axis.text.x = element_text(size = 14),
                axis.text.y = element_text(size = 14),
                axis.title = element_text(size = 14),
                legend.title = element_blank())
  return(p)
}
#Create correlation matrix
pretty_columns = read.csv(paste(new_data, 'pretty_column_names.csv', sep = ''),
                          stringsAsFactors = FALSE)
keep_covid = pretty_columns %>% 
  filter(!is.na(split_word))

keep_covid$l2[keep_covid$l2 == ''] = ' '
keep_covid = keep_covid %>% 
  mutate(formatted_name = paste(l1, l2, sep = "\n"))
  
keep_covid = c('PERCENT_POSITIVE', 'COVID_CASE_RATE', 'COVID_DEATH_RATE')
keep_acs = vars %>% filter(variable_label %in% colnames(merged))
keep_covid = append(keep_covid, as.vector(keep_acs$variable_label))
keep_covid = append(keep_covid, 'crowding')
corr_df = merged %>% 
  select(all_of(keep_covid)) 

merged.rcorr = rcorr(as.matrix(corr_df))
merged.coeff = as.data.frame(merged.rcorr$r)
merged.p = as.data.frame(merged.rcorr$P)

keep_covid = c('PERCENT_POSITIVE', 'COVID_CASE_RATE', 'COVID_DEATH_RATE')
merged.coeff = merged.coeff %>% select(all_of(keep_covid)) 
merged.p = merged.p %>% 
  select('PERCENT_POSITIVE_P' = 'PERCENT_POSITIVE',
         'COVID_CASE_RATE_P' = 'COVID_CASE_RATE',
         'COVID_DEATH_RATE_P' = 'COVID_DEATH_RATE') 

all_cors = cbind(merged.coeff, merged.p)

all_cors['variable'] = rownames(all_cors)
rownames(all_cors) = 1:nrow(all_cors)

sig_cors = all_cors %>% 
  filter(COVID_CASE_RATE_P < 0.05 | COVID_DEATH_RATE_P < 0.05 |PERCENT_POSITIVE_P < 0.05) %>% 
  filter(variable != 'PERCENT_POSITIVE' & variable != 'COVID_CASE_RATE' & variable != 'COVID_DEATH_RATE')
#view significant cors by biggest r value for percent positive
sig_cors %>% 
  arrange(desc(abs(PERCENT_POSITIVE))) %>% 
  select(PERCENT_POSITIVE, PERCENT_POSITIVE_P, variable)

sig_cors %>% 
  arrange(desc(abs(COVID_CASE_RATE))) %>% 
  select(COVID_CASE_RATE, COVID_CASE_RATE_P, variable)

sig_cors %>% 
  arrange(desc(abs(COVID_DEATH_RATE))) %>% 
  select(COVID_DEATH_RATE, COVID_DEATH_RATE_P, variable)
write.csv(all_cors, paste(new_data, 'correlations.csv', sep = ''))

for(c in colnames(corr_df)){
  figname = sprintf("%s_choropleth.png", c)
  png(paste(figs, figname, sep = ''), width = 13, 
      height = 13, units = "in", res = 250)
  p = build_choropleth(choro_inputs, c, c)
  print(p)
  dev.off()
}
library(gridExtra)
png(paste(figs, 'side_by_side_pos_mgmt_art_sci.png', sep = ''), width = 20, 
    height = 15, units = "in", res = 250)
p1 = build_choropleth(choro_inputs, 'PERCENT_POSITIVE', '% of COVID\nTests Positive')
#print(p1)
p2 = build_choropleth(choro_inputs, 'percent_in_mgmt_art_sci', '% Working in Mgmt,\nArts, Science')
grid.arrange(p1, p2, nrow = 1)
dev.off()


#save the merged data frame
#write.csv(corr_df, 'merged_covid_census_data.csv')
#Get correlation matrix

get_correlations <- function(df){
  merged.rcorr = rcorr(as.matrix(df))
  merged.coeff = merged.rcorr$r
  merged.p = merged.rcorr$P
  if(merged.coeff[1,1]!=1.0){
    r_val = merged.coeff[1,1]
    p_val = merged.p[1,1]
  }else{
    r_val = merged.coeff[1,2]
    p_val = merged.p[1,2]
  }
  return(c(r_val, p_val))
}

temp = merged %>% select(PERCENT_POSITIVE, percent_in_mgmt_art_sci)
res = get_correlations(temp)

p = ggplot(temp, aes(percent_in_mgmt_art_sci, PERCENT_POSITIVE))+
  geom_point() +
  labs(y = "percent pos", x = "percent in mgmt arts sci") +
  theme(text = element_text(size = 20))
p = p + geom_smooth(data = temp, method="lm", se=FALSE)
annotation_x = (max(temp$percent_in_mgmt_art_sci) - min(temp$percent_in_mgmt_art_sci))/2
annotation_y = (max(temp$PERCENT_POSITIVE) - min(temp$PERCENT_POSITIVE))/2
p = p + geom_label(x = annotation_x, y = annotation_y,
                   aes(label=sprintf("r = %s, p = %s", as.character(round(res[1], 2)), 
                                     as.character(round(res[2], 3)))),
                   size=4 , fontface="bold" )
print(p)



merged.coeff = as.data.frame(merged.coeff) %>% 
  select(c(PERCENT_POSITIVE))
merged.p = as.data.frame(merged.p) %>% 
  select(c(PERCENT_POSITIVE))
#Make correlation dataframe
all_cors = cbind(merged.coeff, merged.p)
colnames(all_cors) = c('r', 'p')
all_cors['variable'] = rownames(all_cors)
rownames(all_cors) = 1:nrow(all_cors)
#Filter to just significant correlations
#Sort by absolute correlation strength
sig_corrs = all_cors %>% 
  filter(p < 0.05) %>% 
  arrange(desc(abs(r)))
#Add % positive to dataframe
keep_plot = append('PERCENT_POSITIVE', as.vector(sig_corrs$variable))
new_corr_df = corr_df %>% 
  select(all_of(keep_plot))

#create correlation matrix with only significant correlations
new_merged.rcorr = rcorr(as.matrix(new_corr_df))
new_merged.coeff = new_merged.rcorr$r
#plot the new correlation matrix
if(SAVE_FIGS == T){
  png(paste(figs, "cov_correlations.png", sep = ''), width = 13, 
      height = 13, units = "in", res = 250)
  ggcorrplot(new_merged.coeff, type = 'lower')
  dev.off()
}else{
  ggcorrplot(new_merged.coeff, type = 'lower')
}



# OLD 
# 
# 
# 
# 
# png(paste(figs, "choropleth_median_income.png", sep = ''), width = 13, 
#     height = 13, units = "in", res = 250)
# choro$set_zoom_zip(state_zoom = 'new york',county_zoom=nyc_fips, msa_zoom=NULL, zip_zoom=NULL)
# choro$title = "Median income"
# choro$prepare_map()
# choro$ggplot_scale = scale_fill_brewer(name="Median income", palette=2, drop=TRUE)
# choro$render()
# dev.off()
# 
# temp_acs = merged %>% 
#   select(region = ZCTA,
#          value = plot_cols[2])
# figname = sprintf("%s_choropleth.png", plot_cols[2])
# png(paste(figs, figname, sep = ''), width = 13, 
#     height = 13, units = "in", res = 250)
# #Test zip code choropleths
# choro = ZipChoropleth$new(temp_acs)
# choro$set_zoom_zip(state_zoom = 'new york',county_zoom=nyc_fips, msa_zoom=NULL, zip_zoom=NULL)
# choro$title = pretty_cols[2]
# choro$prepare_map()
# choro$ggplot_scale = scale_fill_brewer(name=pretty_cols[2], palette=2, drop=TRUE)
# choro$render_helper(theme = )
# choro$render()
# dev.off()
# 
# 
# 
# # library(rgdal)
# # 
# # nyc_neighborhoods <- readOGR(paste(new_data, 'nyc_zip_code_tabulation_areas.geojson',
# #                                    sep = ''), verbose = T)
# # library(broom)
# # nyc_neighborhoods_df <- tidy(nyc_neighborhoods)
# choro_list = list()
# for(i in 1:3){
#   test_choro = build_choropleth(merged, 
#                                 plot_cols[i], new_vars[i])
#   choro_list = append(choro_list, test_choro)
# }
# 
# 
# temp_cov = merged %>% 
#   select(value = PERCENT_POSITIVE,
#          region = ZCTA)
# 
# choro1 = choroplethrZip::ZipChoropleth$new(temp_cov)
# choro1$set_zoom_zip(state_zoom = 'new york',county_zoom=nyc_fips, msa_zoom=NULL, 
#                     zip_zoom=NULL)
# 
# choro1$title = 'Percent Positive'
# choro1$prepare_map()
# choro1$ggplot_scale = scale_fill_brewer(name='Percent positive', palette=2, drop=TRUE)
# choro1$render()


