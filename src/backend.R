library(dplyr)
library(ggplot2)
library(stats)
library(plotly)
library(Hmisc)
library(stringr)
library(data.table)

source('./src/data_paths.R')

#################################
# Read in geospatial data
#################################
choro_inputs <- read.csv(paste(new_data, choro_fname, sep = ''),
                        stringsAsFactors = FALSE)
choro_inputs$ZCTA <- as.character(choro_inputs$ZCTA)
df <- choro_inputs %>% 
  distinct(ZCTA, .keep_all = TRUE)

#Prep formatted geospatial dataframe 
pretty_columns <- read.csv(paste(new_data, 'pretty_column_names.csv', sep = ''),
                          stringsAsFactors = FALSE)
pretty_columns <- pretty_columns %>% 
  filter(!is.na(split_word))
pretty_columns$l2[pretty_columns$l2 == ''] <- ' '
pretty_columns <- pretty_columns %>% 
  mutate(formatted_name = paste(l1, l2, sep = "\n"),#build names that need to have a newline
         formatted_name = str_trim(formatted_name, side = 'both'), #remove leading/trailing whitespace
         format_1l = paste(l1, l2, sep = ' '), #build names to go on one line
         format_1l = str_trim(format_1l, side = 'both'))

#plot_names is used to rename the choro_inputs columns
plot_names <- as.vector(pretty_columns$original_name)
names(plot_names) <- as.vector(pretty_columns$format_1l)
#rev_names supports plotting with pretty labels
rev_names <- as.vector(pretty_columns$format_1l)
names(rev_names) <- as.vector(pretty_columns$original_name)
#Create df with formatted column names
pretty_choro_inputs <- choro_inputs %>% 
  rename(all_of(plot_names))

#################################
# Read in temporal data
#################################
tests <- read.csv(paste(nyc_data, 'tests.csv', sep = ''),
                 stringsAsFactors = F)

pretty_tests <- tests %>% 
  mutate(Date = as.Date(DATE, format='%m/%d/%Y'),
         `Percent positive tests` = as.integer(PERCENT_POSITIVE*100),
         `Total tests` = as.double(TOTAL_TESTS),
         `Positive tests` = as.double(POSITIVE_TESTS)) %>% 
  select(-c(PERCENT_POSITIVE_3DAYS_AGG, POSITIVE_TESTS,
            TOTAL_TESTS, PERCENT_POSITIVE, DATE))

deaths <- read.csv(paste(nyc_data, 'deaths/probable-confirmed-dod.csv', sep = ''),
                   stringsAsFactors = F)
deaths <- deaths %>% 
  mutate(Date = as.Date(DATE_OF_DEATH, format='%m/%d/%Y'),
         `Total deaths` = as.double(CONFIRMED_COUNT + PROBABLE_COUNT),
         `Probable deaths` = as.double(PROBABLE_COUNT),
         `Confirmed deaths` = as.double(CONFIRMED_COUNT)) %>% 
  select(-c(DATE_OF_DEATH, CONFIRMED_COUNT, PROBABLE_COUNT))

daily <- dplyr::left_join(pretty_tests, deaths, by = "Date")

tests_melted <- melt(data.table(daily %>% 
                                  mutate(`Percent positive tests` = as.character(`Percent positive tests`),
                                         `Percent positive tests` = paste(`Percent positive tests`, 
                                                                          '%', sep = '')) %>% 
                                  select(Date, `Total tests`, `Positive tests`,
                                         `Percent positive tests`, `Total deaths`,
                                         `Confirmed deaths`, `Probable deaths`)), 
                     id.vars = c('Date', 'Percent positive tests', 'Total deaths'))



#################################
# Define geospatial plotting fxns
#################################

BASE_CHOROPLETH <- ggplot(data=pretty_choro_inputs,
                          aes(x = long, y = lat, label = ZCTA)) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank())

# Uses dataframe generated by generate_choro_df to plot desired outcomes
# var_label is the variable name
# pretty_label is var_label but split across multiple lines
build_choropleth <- function(choro_df, var_label, pretty_label,
                             min_color = 'lightgrey', max_color = 'darkblue',
                             show_title = F){
  if(show_title){
    new_title = pretty_label
  }else{
    new_title = ''
  }
  choro_df = choro_df %>% 
    filter(!is.na(.data[[var_label]])) 
  
  p = BASE_CHOROPLETH + 
    geom_polygon(data=choro_df, 
                 aes(x=long, y=lat, group=group,
                     fill = .data[[var_label]]),
                 color = 'white', size = 0.2) +
    scale_fill_gradient(low = min_color, high = max_color, 
                        guide = 
                          guide_colorbar(
                            title = pretty_label,order = 1,reverse = F
                          )
    )+
    labs(title=new_title,
         x ="", y = "")
  
  return(p)
}

#Plot a scatter plot with or without extra summary/grouping features
build_corr_plot <- function(df, xvar, yvar,
                            show_reg, show_boro){
  
  plot_df = df %>% 
    dplyr::filter(!is.na(.data[[xvar]]) & !is.na(.data[[yvar]])) %>% 
    dplyr::distinct(ZCTA, .keep_all = TRUE)
  
  if(show_boro==TRUE){
    p = ggplot(plot_df, aes(.data[[xvar]], .data[[yvar]], label = ZCTA))+
      geom_point(aes(color=Borough)) +
      labs(x = xvar, y = yvar)
  }else{
    p = ggplot(plot_df, aes(.data[[xvar]], .data[[yvar]], label = ZCTA))+
      geom_point()
  }
  if(show_reg==TRUE){
    p = p +  geom_smooth(method = 'lm', se = FALSE, formula = y ~ x)
  }
  p = p + theme(panel.background = element_blank(),
                axis.line = element_line(colour = "black"),
                text = element_text(size = 16),
                axis.text.x = element_text(size = 14),
                axis.text.y = element_text(size = 14),
                axis.title = element_text(size = 14),
                legend.title = element_blank())
  return(p)
}

get_correlations <- function(df){
  merged.rcorr = rcorr(as.matrix(df))
  merged.coeff = merged.rcorr$r
  merged.p = merged.rcorr$P
  if(merged.coeff[1,1]!=1.0){
    r_val = merged.coeff[1,1]
    p_val = merged.p[1,1]
  }else{
    r_val = merged.coeff[1,2]
    p_val = merged.p[1,2]
  }
  return(c(r_val, p_val))
}

#################################
# Define temporal plotting fxns
#################################

build_time_plot <- function(df, var_label, tooltip_var){
  temp = ggplot(data = df, aes(x = Date, y = .data[[var_label]],
                               label = .data[[tooltip_var]]))+
    geom_bar(stat = 'identity', fill = 'turquoise', color = 'white')+
    labs(title= paste(var_label, 'per day'),
         x ="Date", y = var_label)+
    theme(panel.background = element_blank(),
          axis.line = element_line(colour = "black"),
          text = element_text(size = 14),
          axis.text.x = element_text(size = 12),
          axis.text.y = element_text(size = 12),
          axis.title = element_text(size = 12),
          legend.title = element_blank())
  return(temp)
}

build_combined_time_plot <- function(melted_df, plot_type = 'tests'){
  if(plot_type == 'tests'){
    vars = c('Total tests', 'Positive tests')
    temp_df = melted_df %>% 
      filter(variable %in% vars)
    temp = ggplot(data = as.data.frame(temp_df), aes(x = Date, y = value, 
                                                     label = `Percent positive tests`, fill = variable,
                                                     text = paste(variable, value, sep = ': ')))
    title_text='COVID Testing Over Time'
  }else{
    vars = c('Confirmed deaths', 'Probable deaths')
    temp_df = melted_df %>% 
      filter(variable %in% vars)
    temp_df[is.na(temp_df)] = 0
    temp = ggplot(data = as.data.frame(temp_df), aes(x = Date, y = value, 
                                                     label = `Total deaths`, fill = variable,
                                                     text = paste(variable, value, sep = ': ')))
    title_text = 'COVID Deaths Over Time'
  }
  temp = temp +
    geom_bar(stat = 'identity', position = 'stack')+
    scale_fill_discrete(labels = vars)+
    labs(title=title_text,
         x ="Date", y = "Count")+
    theme(panel.background = element_blank(),
          axis.line = element_line(colour = "white"),
          text = element_text(size = 14),
          axis.text.x = element_text(size = 12),
          axis.text.y = element_text(size = 12),
          axis.title = element_text(size = 12),
          legend.title = element_blank())
  return(temp)
}